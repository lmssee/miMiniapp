{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\nvar SourceMapSource = require(\"webpack-sources\").SourceMapSource;\nvar RawSource = require(\"webpack-sources\").RawSource;\nvar ConcatSource = require(\"webpack-sources\").ConcatSource;\nvar RequestShortener = require(\"webpack/lib/RequestShortener\");\nvar ModuleFilenameHelpers = require(\"webpack/lib/ModuleFilenameHelpers\");\nvar uglify = require(\"uglify-js\");\n\nvar UglifyJsPlugin = function () {\n\tfunction UglifyJsPlugin(options) {\n\t\t_classCallCheck(this, UglifyJsPlugin);\n\n\t\tif ((typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) !== \"object\" || Array.isArray(options)) options = {};\n\t\tif (typeof options.compressor !== \"undefined\") options.compress = options.compressor;\n\t\tthis.options = options;\n\t}\n\n\t_createClass(UglifyJsPlugin, [{\n\t\tkey: \"apply\",\n\t\tvalue: function apply(compiler) {\n\t\t\tvar options = this.options;\n\t\t\toptions.test = options.test || /\\.js($|\\?)/i;\n\t\t\tvar warningsFilter = options.warningsFilter || function () {\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\tvar requestShortener = new RequestShortener(compiler.context);\n\t\t\tcompiler.plugin(\"compilation\", function (compilation) {\n\t\t\t\tif (options.sourceMap) {\n\t\t\t\t\tcompilation.plugin(\"build-module\", function (module) {\n\t\t\t\t\t\t// to get detailed location info about errors\n\t\t\t\t\t\tmodule.useSourceMap = true;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcompilation.plugin(\"optimize-chunk-assets\", function (chunks, callback) {\n\t\t\t\t\tvar files = [];\n\t\t\t\t\tchunks.forEach(function (chunk) {\n\t\t\t\t\t\treturn files.push.apply(files, chunk.files);\n\t\t\t\t\t});\n\t\t\t\t\tfiles.push.apply(files, compilation.additionalChunkAssets);\n\t\t\t\t\tvar filteredFiles = files.filter(ModuleFilenameHelpers.matchObject.bind(undefined, options));\n\t\t\t\t\tfilteredFiles.forEach(function (file) {\n\t\t\t\t\t\tvar oldWarnFunction = uglify.AST_Node.warn_function;\n\t\t\t\t\t\tvar warnings = [];\n\t\t\t\t\t\tvar sourceMap = void 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar asset = compilation.assets[file];\n\t\t\t\t\t\t\tif (asset.__UglifyJsPlugin) {\n\t\t\t\t\t\t\t\tcompilation.assets[file] = asset.__UglifyJsPlugin;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar input = void 0;\n\t\t\t\t\t\t\tvar inputSourceMap = void 0;\n\t\t\t\t\t\t\tif (options.sourceMap) {\n\t\t\t\t\t\t\t\tif (asset.sourceAndMap) {\n\t\t\t\t\t\t\t\t\tvar sourceAndMap = asset.sourceAndMap();\n\t\t\t\t\t\t\t\t\tinputSourceMap = sourceAndMap.map;\n\t\t\t\t\t\t\t\t\tinput = sourceAndMap.source;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tinputSourceMap = asset.map();\n\t\t\t\t\t\t\t\t\tinput = asset.source();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsourceMap = new SourceMapConsumer(inputSourceMap);\n\t\t\t\t\t\t\t\tuglify.AST_Node.warn_function = function (warning) {\n\t\t\t\t\t\t\t\t\t// eslint-disable-line camelcase\n\t\t\t\t\t\t\t\t\tvar match = /\\[.+:([0-9]+),([0-9]+)\\]/.exec(warning);\n\t\t\t\t\t\t\t\t\tvar line = +match[1];\n\t\t\t\t\t\t\t\t\tvar column = +match[2];\n\t\t\t\t\t\t\t\t\tvar original = sourceMap.originalPositionFor({\n\t\t\t\t\t\t\t\t\t\tline: line,\n\t\t\t\t\t\t\t\t\t\tcolumn: column\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tif (!original || !original.source || original.source === file) return;\n\t\t\t\t\t\t\t\t\tif (!warningsFilter(original.source)) return;\n\t\t\t\t\t\t\t\t\twarnings.push(warning.replace(/\\[.+:([0-9]+),([0-9]+)\\]/, \"\") + \"[\" + requestShortener.shorten(original.source) + \":\" + original.line + \",\" + original.column + \"]\");\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinput = asset.source();\n\t\t\t\t\t\t\t\tuglify.AST_Node.warn_function = function (warning) {\n\t\t\t\t\t\t\t\t\t// eslint-disable-line camelcase\n\t\t\t\t\t\t\t\t\twarnings.push(warning);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tuglify.base54.reset();\n\t\t\t\t\t\t\tvar ast = uglify.parse(input, {\n\t\t\t\t\t\t\t\tfilename: file\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (options.compress !== false) {\n\t\t\t\t\t\t\t\tast.figure_out_scope();\n\t\t\t\t\t\t\t\tvar compress = uglify.Compressor(options.compress || {\n\t\t\t\t\t\t\t\t\twarnings: false\n\t\t\t\t\t\t\t\t}); // eslint-disable-line new-cap\n\t\t\t\t\t\t\t\tast = compress.compress(ast);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (options.mangle !== false) {\n\t\t\t\t\t\t\t\tast.figure_out_scope(options.mangle || {});\n\t\t\t\t\t\t\t\tast.compute_char_frequency(options.mangle || {});\n\t\t\t\t\t\t\t\tast.mangle_names(options.mangle || {});\n\t\t\t\t\t\t\t\tif (options.mangle && options.mangle.props) {\n\t\t\t\t\t\t\t\t\tuglify.mangle_properties(ast, options.mangle.props);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar output = {};\n\t\t\t\t\t\t\toutput.comments = Object.prototype.hasOwnProperty.call(options, \"comments\") ? options.comments : /^\\**!|@preserve|@license/;\n\t\t\t\t\t\t\toutput.beautify = options.beautify;\n\t\t\t\t\t\t\tfor (var k in options.output) {\n\t\t\t\t\t\t\t\toutput[k] = options.output[k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar extractedComments = [];\n\t\t\t\t\t\t\tif (options.extractComments) {\n\t\t\t\t\t\t\t\tvar condition = {};\n\t\t\t\t\t\t\t\tif (typeof options.extractComments === \"string\" || options.extractComments instanceof RegExp) {\n\t\t\t\t\t\t\t\t\t// extractComments specifies the extract condition and output.comments specifies the preserve condition\n\t\t\t\t\t\t\t\t\tcondition.preserve = output.comments;\n\t\t\t\t\t\t\t\t\tcondition.extract = options.extractComments;\n\t\t\t\t\t\t\t\t} else if (Object.prototype.hasOwnProperty.call(options.extractComments, \"condition\")) {\n\t\t\t\t\t\t\t\t\t// Extract condition is given in extractComments.condition\n\t\t\t\t\t\t\t\t\tcondition.preserve = output.comments;\n\t\t\t\t\t\t\t\t\tcondition.extract = options.extractComments.condition;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// No extract condition is given. Extract comments that match output.comments instead of preserving them\n\t\t\t\t\t\t\t\t\tcondition.preserve = false;\n\t\t\t\t\t\t\t\t\tcondition.extract = output.comments;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Ensure that both conditions are functions\n\t\t\t\t\t\t\t\t[\"preserve\", \"extract\"].forEach(function (key) {\n\t\t\t\t\t\t\t\t\tswitch (_typeof(condition[key])) {\n\t\t\t\t\t\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\t\t\t\t\t\tvar b = condition[key];\n\t\t\t\t\t\t\t\t\t\t\tcondition[key] = function () {\n\t\t\t\t\t\t\t\t\t\t\t\treturn b;\n\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\t\t\t\t\t\tif (condition[key] === \"all\") {\n\t\t\t\t\t\t\t\t\t\t\t\tcondition[key] = function () {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tvar regex = new RegExp(condition[key]);\n\t\t\t\t\t\t\t\t\t\t\tcondition[key] = function (astNode, comment) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn regex.test(comment.value);\n\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tregex = condition[key];\n\t\t\t\t\t\t\t\t\t\t\tcondition[key] = function (astNode, comment) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn regex.test(comment.value);\n\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t// Redefine the comments function to extract and preserve\n\t\t\t\t\t\t\t\t// comments according to the two conditions\n\t\t\t\t\t\t\t\toutput.comments = function (astNode, comment) {\n\t\t\t\t\t\t\t\t\tif (condition.extract(astNode, comment)) {\n\t\t\t\t\t\t\t\t\t\textractedComments.push(comment.type === \"comment2\" ? \"/*\" + comment.value + \"*/\" : \"//\" + comment.value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn condition.preserve(astNode, comment);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar map = void 0;\n\t\t\t\t\t\t\tif (options.sourceMap) {\n\t\t\t\t\t\t\t\tmap = uglify.SourceMap({ // eslint-disable-line new-cap\n\t\t\t\t\t\t\t\t\tfile: file,\n\t\t\t\t\t\t\t\t\troot: \"\"\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\toutput.source_map = map; // eslint-disable-line camelcase\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar stream = uglify.OutputStream(output); // eslint-disable-line new-cap\n\t\t\t\t\t\t\tast.print(stream);\n\t\t\t\t\t\t\tif (map) map = map + \"\";\n\t\t\t\t\t\t\tvar stringifiedStream = stream + \"\";\n\t\t\t\t\t\t\tvar outputSource = map ? new SourceMapSource(stringifiedStream, file, JSON.parse(map), input, inputSourceMap) : new RawSource(stringifiedStream);\n\t\t\t\t\t\t\tif (extractedComments.length > 0) {\n\t\t\t\t\t\t\t\tvar commentsFile = options.extractComments.filename || file + \".LICENSE\";\n\t\t\t\t\t\t\t\tif (typeof commentsFile === \"function\") {\n\t\t\t\t\t\t\t\t\tcommentsFile = commentsFile(file);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Write extracted comments to commentsFile\n\t\t\t\t\t\t\t\tvar commentsSource = new RawSource(extractedComments.join(\"\\n\\n\") + \"\\n\");\n\t\t\t\t\t\t\t\tif (commentsFile in compilation.assets) {\n\t\t\t\t\t\t\t\t\t// commentsFile already exists, append new comments...\n\t\t\t\t\t\t\t\t\tif (compilation.assets[commentsFile] instanceof ConcatSource) {\n\t\t\t\t\t\t\t\t\t\tcompilation.assets[commentsFile].add(\"\\n\");\n\t\t\t\t\t\t\t\t\t\tcompilation.assets[commentsFile].add(commentsSource);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcompilation.assets[commentsFile] = new ConcatSource(compilation.assets[commentsFile], \"\\n\", commentsSource);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcompilation.assets[commentsFile] = commentsSource;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Add a banner to the original file\n\t\t\t\t\t\t\t\tif (options.extractComments.banner !== false) {\n\t\t\t\t\t\t\t\t\tvar banner = options.extractComments.banner || \"For license information please see \" + commentsFile;\n\t\t\t\t\t\t\t\t\tif (typeof banner === \"function\") {\n\t\t\t\t\t\t\t\t\t\tbanner = banner(commentsFile);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (banner) {\n\t\t\t\t\t\t\t\t\t\toutputSource = new ConcatSource(\"/*! \" + banner + \" */\\n\", outputSource);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tasset.__UglifyJsPlugin = compilation.assets[file] = outputSource;\n\t\t\t\t\t\t\tif (warnings.length > 0) {\n\t\t\t\t\t\t\t\tcompilation.warnings.push(new Error(file + \" from UglifyJs\\n\" + warnings.join(\"\\n\")));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tif (err.line) {\n\t\t\t\t\t\t\t\tvar original = sourceMap && sourceMap.originalPositionFor({\n\t\t\t\t\t\t\t\t\tline: err.line,\n\t\t\t\t\t\t\t\t\tcolumn: err.col\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (original && original.source) {\n\t\t\t\t\t\t\t\t\tcompilation.errors.push(new Error(file + \" from UglifyJs\\n\" + err.message + \" [\" + requestShortener.shorten(original.source) + \":\" + original.line + \",\" + original.column + \"][\" + file + \":\" + err.line + \",\" + err.col + \"]\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcompilation.errors.push(new Error(file + \" from UglifyJs\\n\" + err.message + \" [\" + file + \":\" + err.line + \",\" + err.col + \"]\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (err.msg) {\n\t\t\t\t\t\t\t\tcompilation.errors.push(new Error(file + \" from UglifyJs\\n\" + err.msg));\n\t\t\t\t\t\t\t} else compilation.errors.push(new Error(file + \" from UglifyJs\\n\" + err.stack));\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tuglify.AST_Node.warn_function = oldWarnFunction; // eslint-disable-line camelcase\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}]);\n\n\treturn UglifyJsPlugin;\n}();\n\nmodule.exports = UglifyJsPlugin;"]}