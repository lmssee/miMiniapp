{"version":3,"sources":["index.js","SourceListMap.js","CodeNode.js","helpers.js","SourceNode.js","base64-vlq.js","SingleLineNode.js","MappingsContext.js","fromStringWithSourceMap.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ACHA,AFMA;ADIA,ADGA,AGTA,ACHA,AFMA;ADIA,ADGA,AGTA,ACHA,AFMA;ADIA,AIZA,ALeA,AGTA,ACHA,AFMA;ADIA,AIZA,ALeA,AGTA,ACHA,AFMA;ADIA,AIZA,ALeA,AGTA,ACHA,AFMA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AFMA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AFMA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AFMA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA,ALeA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA,ALeA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA,ALeA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA,ALeA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA,ALeA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA,ALeA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA,ALeA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA,ALeA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA,ALeA;ADIA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AKfA,ADGA,ALeA,AGTA,ACHA,AGTA;ANmBA,AIZA,ALeA,AGTA,ACHA,AGTA;ANmBA,AIZA,ALeA,AGTA,ACHA,AGTA;ANmBA,AIZA,ALeA,AGTA,ACHA,AGTA;ANmBA,AIZA,ALeA,AGTA,ACHA,AGTA;ANmBA,AIZA,ALeA,AGTA,ACHA,AGTA;ANmBA,AIZA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;AFOA,ALeA,AGTA,ACHA,AGTA;APsBA,AGTA,ACHA,AGTA;APsBA,AGTA,ACHA,AGTA;APsBA,AGTA,ACHA,AGTA;APsBA,AGTA,ACHA,AGTA;APsBA,AGTA,ACHA,AGTA;APsBA,AGTA,ACHA,AGTA;APsBA,AGTA,ACHA,AGTA;APsBA,AGTA,ACHA,AGTA;APsBA,AGTA,ACHA,AGTA;AJaA,ACHA,AGTA;AJaA,ACHA,AGTA;AJaA,ACHA,AGTA;AJaA,ACHA,AGTA;AJaA,ACHA,AGTA;AJaA,ACHA,AGTA;AJaA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["exports.SourceListMap = require(\"./SourceListMap\");\nexports.SourceNode = require(\"./SourceNode\");\nexports.SingleLineNode = require(\"./SingleLineNode\");\nexports.CodeNode = require(\"./CodeNode\");\nexports.MappingsContext = require(\"./MappingsContext\");\nexports.fromStringWithSourceMap = require(\"./fromStringWithSourceMap\");\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst CodeNode = require(\"./CodeNode\");\nconst SourceNode = require(\"./SourceNode\");\nconst MappingsContext = require(\"./MappingsContext\");\nconst getNumberOfLines = require(\"./helpers\").getNumberOfLines;\n\nclass SourceListMap {\n\n\tconstructor(generatedCode, source, originalSource) {\n\t\tif(Array.isArray(generatedCode)) {\n\t\t\tthis.children = generatedCode;\n\t\t} else {\n\t\t\tthis.children = [];\n\t\t\tif(generatedCode || source)\n\t\t\t\tthis.add(generatedCode, source, originalSource);\n\t\t}\n\t}\n\n\tadd(generatedCode, source, originalSource) {\n\t\tif(typeof generatedCode === \"string\") {\n\t\t\tif(source) {\n\t\t\t\tthis.children.push(new SourceNode(generatedCode, source, originalSource));\n\t\t\t} else if(this.children.length > 0 && this.children[this.children.length - 1] instanceof CodeNode) {\n\t\t\t\tthis.children[this.children.length - 1].addGeneratedCode(generatedCode);\n\t\t\t} else {\n\t\t\t\tthis.children.push(new CodeNode(generatedCode));\n\t\t\t}\n\t\t} else if(generatedCode.getMappings && generatedCode.getGeneratedCode) {\n\t\t\tthis.children.push(generatedCode);\n\t\t} else if(generatedCode.children) {\n\t\t\tgeneratedCode.children.forEach(function(sln) {\n\t\t\t\tthis.children.push(sln);\n\t\t\t}, this);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid arguments to SourceListMap.protfotype.add: Expected string, Node or SourceListMap\");\n\t\t}\n\t};\n\n\tpreprend(generatedCode, source, originalSource) {\n\t\tif(typeof generatedCode === \"string\") {\n\t\t\tif(source) {\n\t\t\t\tthis.children.unshift(new SourceNode(generatedCode, source, originalSource));\n\t\t\t} else if(this.children.length > 0 && this.children[this.children.length - 1].preprendGeneratedCode) {\n\t\t\t\tthis.children[this.children.length - 1].preprendGeneratedCode(generatedCode);\n\t\t\t} else {\n\t\t\t\tthis.children.unshift(new CodeNode(generatedCode));\n\t\t\t}\n\t\t} else if(generatedCode.getMappings && generatedCode.getGeneratedCode) {\n\t\t\tthis.children.unshift(generatedCode);\n\t\t} else if(generatedCode.children) {\n\t\t\tgeneratedCode.children.slice().reverse().forEach(function(sln) {\n\t\t\t\tthis.children.unshift(sln);\n\t\t\t}, this);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid arguments to SourceListMap.protfotype.prerend: Expected string, Node or SourceListMap\");\n\t\t}\n\t};\n\n\tmapGeneratedCode(fn) {\n\t\tconst normalizedNodes = [];\n\t\tthis.children.forEach(function(sln) {\n\t\t\tsln.getNormalizedNodes().forEach(function(newNode) {\n\t\t\t\tnormalizedNodes.push(newNode);\n\t\t\t});\n\t\t});\n\t\tconst optimizedNodes = [];\n\t\tnormalizedNodes.forEach(function(sln) {\n\t\t\tsln = sln.mapGeneratedCode(fn);\n\t\t\tif(optimizedNodes.length === 0) {\n\t\t\t\toptimizedNodes.push(sln);\n\t\t\t} else {\n\t\t\t\tconst last = optimizedNodes[optimizedNodes.length - 1];\n\t\t\t\tconst mergedNode = last.merge(sln);\n\t\t\t\tif(mergedNode) {\n\t\t\t\t\toptimizedNodes[optimizedNodes.length - 1] = mergedNode;\n\t\t\t\t} else {\n\t\t\t\t\toptimizedNodes.push(sln);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn new SourceListMap(optimizedNodes);\n\t};\n\n\ttoString() {\n\t\treturn this.children.map(function(sln) {\n\t\t\treturn sln.getGeneratedCode();\n\t\t}).join(\"\");\n\t};\n\n\ttoStringWithSourceMap(options) {\n\t\tconst mappingsContext = new MappingsContext();\n\t\tconst source = this.children.map(function(sln) {\n\t\t\treturn sln.getGeneratedCode();\n\t\t}).join(\"\");\n\t\tconst mappings = this.children.map(function(sln) {\n\t\t\treturn sln.getMappings(mappingsContext);\n\t\t}).join(\"\");\n\t\tconst arrays = mappingsContext.getArrays();\n\t\treturn {\n\t\t\tsource,\n\t\t\tmap: {\n\t\t\t\tversion: 3,\n\t\t\t\tfile: options && options.file,\n\t\t\t\tsources: arrays.sources,\n\t\t\t\tsourcesContent: mappingsContext.hasSourceContent ? arrays.sourcesContent : undefined,\n\t\t\t\tmappings: mappings\n\t\t\t}\n\t\t};\n\t}\n}\n\nmodule.exports = SourceListMap;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst getNumberOfLines = require(\"./helpers\").getNumberOfLines;\nconst getUnfinishedLine = require(\"./helpers\").getUnfinishedLine;\n\nclass CodeNode {\n\tconstructor(generatedCode) {\n\t\tthis.generatedCode = generatedCode;\n\t}\n\n\tclone() {\n\t\treturn new CodeNode(this.generatedCode);\n\t}\n\n\tgetGeneratedCode() {\n\t\treturn this.generatedCode;\n\t}\n\n\tgetMappings(mappingsContext) {\n\t\tconst lines = getNumberOfLines(this.generatedCode);\n\t\tconst mapping = Array(lines+1).join(\";\");\n\t\tif(lines > 0) {\n\t\t\tmappingsContext.unfinishedGeneratedLine = getUnfinishedLine(this.generatedCode);\n\t\t\tif(mappingsContext.unfinishedGeneratedLine > 0) {\n\t\t\t\treturn mapping + \"A\";\n\t\t\t} else {\n\t\t\t\treturn mapping;\n\t\t\t}\n\t\t} else {\n\t\t\tconst prevUnfinished = mappingsContext.unfinishedGeneratedLine;\n\t\t\tmappingsContext.unfinishedGeneratedLine += getUnfinishedLine(this.generatedCode);\n\t\t\tif(prevUnfinished === 0 && mappingsContext.unfinishedGeneratedLine > 0) {\n\t\t\t\treturn \"A\";\n\t\t\t} else {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\taddGeneratedCode(generatedCode) {\n\t\tthis.generatedCode += generatedCode;\n\t}\n\n\tmapGeneratedCode(fn) {\n\t\tconst generatedCode = fn(this.generatedCode);\n\t\treturn new CodeNode(generatedCode);\n\t}\n\n\tgetNormalizedNodes() {\n\t\treturn [this];\n\t}\n\n\tmerge(otherNode) {\n\t\tif(otherNode instanceof CodeNode) {\n\t\t\tthis.generatedCode += otherNode.generatedCode;\n\t\t\treturn this;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nmodule.exports = CodeNode;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nexports.getNumberOfLines = function getNumberOfLines(str) {\n\tlet nr = -1;\n\tlet idx = -1;\n\tdo {\n\t\tnr++\n\t\tidx = str.indexOf(\"\\n\", idx + 1);\n\t} while(idx >= 0);\n\treturn nr;\n};\n\nexports.getUnfinishedLine = function getUnfinishedLine(str) {\n\tconst idx = str.lastIndexOf(\"\\n\");\n\tif(idx === -1)\n\t\treturn str.length;\n\telse\n\t\treturn str.length - idx - 1;\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst base64VLQ = require(\"./base64-vlq\");\nconst getNumberOfLines = require(\"./helpers\").getNumberOfLines;\nconst getUnfinishedLine = require(\"./helpers\").getUnfinishedLine;\n\nconst LINE_MAPPING = \";AACA\";\n\nclass SourceNode {\n\n\tconstructor(generatedCode, source, originalSource, startingLine) {\n\t\tthis.generatedCode = generatedCode;\n\t\tthis.originalSource = originalSource;\n\t\tthis.source = source;\n\t\tthis.startingLine = startingLine || 1;\n\t\tthis._numberOfLines = getNumberOfLines(this.generatedCode);\n\t\tthis._endsWithNewLine = generatedCode[generatedCode.length - 1] === \"\\n\";\n\t}\n\n\tclone() {\n\t\treturn new SourceNode(this.generatedCode, this.source, this.originalSource, this.startingLine);\n\t}\n\n\tgetGeneratedCode() {\n\t\treturn this.generatedCode;\n\t}\n\n\taddGeneratedCode(code) {\n\t\tthis.generatedCode += code;\n\t\tthis._numberOfLines += getNumberOfLines(code);\n\t\tthis._endsWithNewLine = code[code.length - 1] === \"\\n\";\n\t}\n\n\tgetMappings(mappingsContext) {\n\t\tif(!this.generatedCode)\n\t\t\treturn \"\";\n\t\tconst lines = this._numberOfLines;\n\t\tconst sourceIdx = mappingsContext.ensureSource(this.source, this.originalSource);\n\t\tlet mappings = \"A\"; // generated column 0\n\t\tif(mappingsContext.unfinishedGeneratedLine)\n\t\t\tmappings = \",\" + base64VLQ.encode(mappingsContext.unfinishedGeneratedLine);\n\t\tmappings += base64VLQ.encode(sourceIdx - mappingsContext.currentSource); // source index\n\t\tmappings += base64VLQ.encode(this.startingLine - mappingsContext.currentOriginalLine); // original line index\n\t\tmappings += \"A\"; // original column 0\n\t\tmappingsContext.currentSource = sourceIdx;\n\t\tmappingsContext.currentOriginalLine = this.startingLine + lines - 1;\n\t\tconst unfinishedGeneratedLine = mappingsContext.unfinishedGeneratedLine = getUnfinishedLine(this.generatedCode)\n\t\tmappings += Array(lines).join(LINE_MAPPING);\n\t\tif(unfinishedGeneratedLine === 0) {\n\t\t\tmappings += \";\";\n\t\t} else {\n\t\t\tif(lines !== 0) {\n\t\t\t\tmappings += LINE_MAPPING;\n\t\t\t}\n\t\t\tmappingsContext.currentOriginalLine++;\n\t\t}\n\t\treturn mappings;\n\t}\n\n\tmapGeneratedCode(fn) {\n\t\tthrow new Error(\"Cannot map generated code on a SourceMap. Normalize to SingleLineNode first.\");\n\t}\n\n\tgetNormalizedNodes() {\n\t\tvar results = [];\n\t\tvar currentLine = this.startingLine;\n\t\tvar generatedCode = this.generatedCode;\n\t\tvar index = 0;\n\t\tvar indexEnd = generatedCode.length;\n\t\twhile(index < indexEnd) {\n\t\t\t// get one generated line\n\t\t\tvar nextLine = generatedCode.indexOf(\"\\n\", index) + 1;\n\t\t\tif(nextLine === 0) nextLine = indexEnd;\n\t\t\tvar lineGenerated = generatedCode.substr(index, nextLine - index);\n\n\t\t\tresults.push(new SingleLineNode(lineGenerated, this.source, this.originalSource, currentLine));\n\n\t\t\t// move cursors\n\t\t\tindex = nextLine;\n\t\t\tcurrentLine++;\n\t\t}\n\t\treturn results;\n\t}\n\n\tmerge(otherNode) {\n\t\tif(otherNode instanceof SourceNode) {\n\t\t\treturn this.mergeSourceNode(otherNode);\n\t\t} else if(otherNode instanceof SingleLineNode) {\n\t\t\treturn this.mergeSingleLineNode(otherNode);\n\t\t}\n\t\treturn false;\n\t}\n\n\tmergeSourceNode(otherNode) {\n\t\tif(this.source === otherNode.source &&\n\t\t\tthis._endsWithNewLine &&\n\t\t\tthis.startingLine + this._numberOfLines === otherNode.startingLine) {\n\t\t\tthis.generatedCode += otherNode.generatedCode;\n\t\t\tthis._numberOfLines += otherNode._numberOfLines;\n\t\t\tthis._endsWithNewLine = otherNode._endsWithNewLine;\n\t\t\treturn this;\n\t\t}\n\t\treturn false;\n\t}\n\n\tmergeSingleLineNode(otherNode) {\n\t\tif(this.source === otherNode.source &&\n\t\t\tthis._endsWithNewLine &&\n\t\t\tthis.startingLine + this._numberOfLines === otherNode.line &&\n\t\t\totherNode._numberOfLines <= 1) {\n\t\t\tthis.addSingleLineNode(otherNode);\n\t\t\treturn this;\n\t\t}\n\t\treturn false;\n\t}\n\n\taddSingleLineNode(otherNode) {\n\t\tthis.generatedCode += otherNode.generatedCode;\n\t\tthis._numberOfLines += otherNode._numberOfLines\n\t\tthis._endsWithNewLine = otherNode._endsWithNewLine;\n\t}\n}\n\nmodule.exports = SourceNode;\nconst SingleLineNode = require(\"./SingleLineNode\"); // circular dependency\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*eslint no-bitwise:0,quotes:0,global-strict:0*/\n\nvar charToIntMap = {};\nvar intToCharMap = {};\n\n'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  .split('')\n  .forEach(function (ch, index) {\n    charToIntMap[ch] = index;\n    intToCharMap[index] = ch;\n  });\n\nvar base64 = {};\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nbase64.encode = function base64_encode(aNumber) {\n  if (aNumber in intToCharMap) {\n    return intToCharMap[aNumber];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + aNumber);\n};\n\n/**\n * Decode a single base 64 digit to an integer.\n */\nbase64.decode = function base64_decode(aChar) {\n  if (aChar in charToIntMap) {\n    return charToIntMap[aChar];\n  }\n  throw new TypeError(\"Not a valid base 64 digit: \" + aChar);\n};\n\n\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aOutParam) {\n  var i = 0;\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (i >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n    digit = base64.decode(aStr.charAt(i++));\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aStr.slice(i);\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst base64VLQ = require(\"./base64-vlq\");\nconst getNumberOfLines = require(\"./helpers\").getNumberOfLines;\nconst getUnfinishedLine = require(\"./helpers\").getUnfinishedLine;\n\nconst LINE_MAPPING = \";AAAA\";\n\nclass SingleLineNode {\n\n\tconstructor(generatedCode, source, originalSource, line) {\n\t\tthis.generatedCode = generatedCode;\n\t\tthis.originalSource = originalSource;\n\t\tthis.source = source;\n\t\tthis.line = line || 1;\n\t\tthis._numberOfLines = getNumberOfLines(this.generatedCode);\n\t\tthis._endsWithNewLine = generatedCode[generatedCode.length - 1] === \"\\n\";\n\t}\n\n\tclone() {\n\t\treturn new SingleLineNode(this.generatedCode, this.source, this.originalSource, this.line);\n\t}\n\n\tgetGeneratedCode() {\n\t\treturn this.generatedCode;\n\t}\n\n\tgetMappings(mappingsContext) {\n\t\tif(!this.generatedCode)\n\t\t\treturn \"\";\n\t\tconst lines = this._numberOfLines;\n\t\tconst sourceIdx = mappingsContext.ensureSource(this.source, this.originalSource);\n\t\tlet mappings = \"A\"; // generated column 0\n\t\tif(mappingsContext.unfinishedGeneratedLine)\n\t\t\tmappings = \",\" + base64VLQ.encode(mappingsContext.unfinishedGeneratedLine);\n\t\tmappings += base64VLQ.encode(sourceIdx - mappingsContext.currentSource); // source index\n\t\tmappings += base64VLQ.encode(this.line - mappingsContext.currentOriginalLine); // original line index\n\t\tmappings += \"A\"; // original column 0\n\t\tmappingsContext.currentSource = sourceIdx;\n\t\tmappingsContext.currentOriginalLine = this.line;\n\t\tconst unfinishedGeneratedLine = mappingsContext.unfinishedGeneratedLine = getUnfinishedLine(this.generatedCode)\n\t\tmappings += Array(lines).join(LINE_MAPPING);\n\t\tif(unfinishedGeneratedLine === 0) {\n\t\t\tmappings += \";\";\n\t\t} else {\n\t\t\tif(lines !== 0)\n\t\t\t\tmappings += LINE_MAPPING;\n\t\t}\n\t\treturn mappings;\n\t}\n\n\tgetNormalizedNodes() {\n\t\treturn [this];\n\t}\n\n\tmapGeneratedCode(fn) {\n\t\tconst generatedCode = fn(this.generatedCode);\n\t\treturn new SingleLineNode(generatedCode, this.source, this.originalSource, this.line);\n\t}\n\n\tmerge(otherNode) {\n\t\tif(otherNode instanceof SingleLineNode) {\n\t\t\treturn this.mergeSingleLineNode(otherNode);\n\t\t}\n\t\treturn false;\n\t}\n\n\tmergeSingleLineNode(otherNode) {\n\t\tif(this.source === otherNode.source &&\n\t\t\tthis.originalSource === otherNode.originalSource) {\n\t\t\tif(this.line === otherNode.line) {\n\t\t\t\tthis.generatedCode += otherNode.generatedCode;\n\t\t\t\tthis._numberOfLines += otherNode._numberOfLines;\n\t\t\t\tthis._endsWithNewLine = otherNode._endsWithNewLine;\n\t\t\t\treturn this;\n\t\t\t} else if(this.line + 1 === otherNode.line && \n\t\t\t\tthis._endsWithNewLine &&\n\t\t\t\tthis._numberOfLines === 1 && \n\t\t\t\totherNode._numberOfLines <= 1) {\n\t\t\t\treturn new SourceNode(this.generatedCode + otherNode.generatedCode, this.source, this.originalSource, this.line);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\nmodule.exports = SingleLineNode;\n\nconst SourceNode = require(\"./SourceNode\"); // circular dependency\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nclass MappingsContext {\n\tconstructor() {\n\t\tthis.sourcesIndices = new Map();\n\t\tthis.sourcesContent = new Map();\n\t\tthis.hasSourceContent = false;\n\t\tthis.currentOriginalLine = 1;\n\t\tthis.currentSource = 0;\n\t\tthis.unfinishedGeneratedLine = false;\n\t}\n\n\tensureSource(source, originalSource) {\n\t\tlet idx = this.sourcesIndices.get(source);\n\t\tif(typeof idx === \"number\") {\n\t\t\treturn idx;\n\t\t}\n\t\tidx = this.sourcesIndices.size;\n\t\tthis.sourcesIndices.set(source, idx);\n\t\tthis.sourcesContent.set(source, originalSource)\n\t\tif(typeof originalSource === \"string\")\n\t\t\tthis.hasSourceContent = true;\n\t\treturn idx;\n\t}\n\n\tgetArrays() {\n\t\tconst sources = [];\n\t\tconst sourcesContent = [];\n\n\t\tfor(const pair of this.sourcesContent) {\n\t\t\tsources.push(pair[0]);\n\t\t\tsourcesContent.push(pair[1]);\n\t\t}\n\n\t\treturn {\n\t\t\tsources,\n\t\t\tsourcesContent\n\t\t};\n\t}\n}\nmodule.exports = MappingsContext;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst base64VLQ = require(\"./base64-vlq\");\nconst SourceNode = require(\"./SourceNode\");\nconst CodeNode = require(\"./CodeNode\");\nconst SourceListMap = require(\"./SourceListMap\");\n\nmodule.exports = function fromStringWithSourceMap(code, map) {\n\tconst sources = map.sources;\n\tconst sourcesContent = map.sourcesContent;\n\tconst mappings = map.mappings.split(\";\");\n\tconst lines = code.split(\"\\n\");\n\tconst nodes = [];\n\tlet currentNode = null;\n\tlet currentLine = 1;\n\tlet currentSourceIdx = 0;\n\tlet currentSourceNodeLine;\n\tfunction addCode(generatedCode) {\n\t\tif(currentNode && currentNode instanceof CodeNode) {\n\t\t\tcurrentNode.addGeneratedCode(generatedCode);\n\t\t} else if(currentNode && currentNode instanceof SourceNode && !generatedCode.trim()) {\n\t\t\tcurrentNode.addGeneratedCode(generatedCode);\n\t\t\tcurrentSourceNodeLine++;\n\t\t} else {\n\t\t\tcurrentNode = new CodeNode(generatedCode);\n\t\t\tnodes.push(currentNode);\n\t\t}\n\t}\n\tfunction addSource(generatedCode, source, originalSource, linePosition) {\n\t\tif(currentNode && currentNode instanceof SourceNode &&\n\t\t\tcurrentNode.source === source &&\n\t\t\tcurrentSourceNodeLine === linePosition\n\t\t) {\n\t\t\tcurrentNode.addGeneratedCode(generatedCode);\n\t\t\tcurrentSourceNodeLine++;\n\t\t} else {\n\t\t\tcurrentNode = new SourceNode(generatedCode, source, originalSource, linePosition);\n\t\t\tcurrentSourceNodeLine = linePosition + 1;\n\t\t\tnodes.push(currentNode);\n\t\t}\n\t}\n\tmappings.forEach(function(mapping, idx) {\n\t\tlet line = lines[idx];\n\t\tif(typeof line === 'undefined') return;\n\t\tif(idx !== lines.length - 1) line += \"\\n\";\n\t\tif(!mapping)\n\t\t\treturn addCode(line);\n\t\tmapping = { value: 0, rest: mapping };\n\t\tlet lineAdded = false;\n\t\twhile(mapping.rest)\n\t\t\tlineAdded = processMapping(mapping, line, lineAdded) || lineAdded;\n\t\tif(!lineAdded)\n\t\t\taddCode(line);\n\t});\n\tif(mappings.length < lines.length) {\n\t\tlet idx = mappings.length;\n\t\twhile(!lines[idx].trim() && idx < lines.length-1) {\n\t\t\taddCode(lines[idx] + \"\\n\");\n\t\t\tidx++;\n\t\t}\n\t\taddCode(lines.slice(idx).join(\"\\n\"));\n\t}\n\treturn new SourceListMap(nodes);\n\tfunction processMapping(mapping, line, ignore) {\n\t\tif(mapping.rest && mapping.rest[0] !== \",\") {\n\t\t\tbase64VLQ.decode(mapping.rest, mapping);\n\t\t}\n\t\tif(!mapping.rest)\n\t\t\treturn false;\n\t\tif(mapping.rest[0] === \",\") {\n\t\t\tmapping.rest = mapping.rest.substr(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tbase64VLQ.decode(mapping.rest, mapping);\n\t\tconst sourceIdx = mapping.value + currentSourceIdx;\n\t\tcurrentSourceIdx = sourceIdx;\n\n\t\tlet linePosition;\n\t\tif(mapping.rest && mapping.rest[0] !== \",\") {\n\t\t\tbase64VLQ.decode(mapping.rest, mapping);\n\t\t\tlinePosition = mapping.value + currentLine;\n\t\t\tcurrentLine = linePosition;\n\t\t} else {\n\t\t\tlinePosition = currentLine;\n\t\t}\n\n\t\tif(mapping.rest) {\n\t\t\tconst next = mapping.rest.indexOf(\",\");\n\t\t\tmapping.rest = next === -1 ? \"\" : mapping.rest.substr(next);\n\t\t}\n\n\t\tif(!ignore) {\n\t\t\taddSource(line, sources ? sources[sourceIdx] : null, sourcesContent ? sourcesContent[sourceIdx] : null, linePosition)\n\t\t\treturn true;\n\t\t}\n\t}\n};\n"]}